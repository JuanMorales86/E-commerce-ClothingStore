//En el navbar original que hice ahora lo cmabie a un navbar predeterminado de material
<Toolbar sx={{ display:'flex', justifyContent: 'space-around', fontweight: 'bold'  , alignItems: 'center', gap:'2rem', color: 'black', backgroundColor:'primary.dark'}}>
//-------------

//Si quiero cambiar el estilo del elemento del componenete Tabs de materialui: ('& .MuiTab-root')

En el contexto de estilos en Material-UI, & se refiere al elemento actual al que se le est치n aplicando los estilos y . se utiliza para seleccionar una clase.

En el caso de & .MuiTab-root, se est치 seleccionando el elemento Tab que tiene la clase MuiTab-root dentro del componente Tabs. Esto permite aplicar estilos espec칤ficos a ese elemento en particular.

En resumen, & .MuiTab-root se utiliza como un selector CSS para apuntar a los elementos Tab dentro de Tabs y aplicar los estilos definidos.

ejemplo: 

 <Tabs
      value={value}
      onChange={(event, newValue) => {//si quiero usar mas funciones dentro de un onchange que maneja una funcion padre los coloco en un function arrow
        handleChange(event, newValue);
        handlePush(event, newValue);
      }}
      textColor="secondary"
      indicatorColor="secondary"
      aria-label="secondary tabs example"
      sx={{ '& .MuiTab-root' : {//llamo a elemento actual & despues la clase q controla el css de materialui en la tabs .MuiTab-root, hago los cambios
      fontFamily: 'Arial, sans-serif',
      fontWeight: 'bold',
      fontSize: '1rem',
      textTransform: 'upperCase'
      }
      }}
      >
      <Tab value="Vestir" label="Vestir" />
      <Tab value="Casual" label="Casual" />
      <Tab value="Deportiva" label="Deportiva" />
      <Tab value="Todas" label="Todas" />
    </Tabs>
    </Box>
    <Box>
            {/* desiciones de las tabs */}
        {
            tabPush === 'Vestir' ?
                <Box>RopaVestidos</Box>
            :
            null
        }
          {
            tabPush === 'Casual' ?
                <Box>RopaCasual</Box>
            :
            null
        }
           {
            tabPush === 'Deportiva' ?
                <Box>RopaDeportiva</Box>
            :
            null
        }
           {
            tabPush === 'Todas' ?
                <Box>Todalamercancia</Box>
            :
            null
        }
    </Box>
      <Tabs/>

En el c칩digo anterior, he utilizado el selector & .MuiTab-root dentro del prop sx de Tabs para aplicar estilos al elemento Tab dentro de las pesta침as. Dentro de ese selector, puedes especificar los estilos que deseas, como la familia de fuentes (fontFamily), el peso de la fuente (fontWeight), el tama침o de la fuente (fontSize), y la transformaci칩n de texto (textTransform).
//---------------

//Haciendo get con axios

El problema que est치s experimentando se debe a un error en la forma en que est치s manejando la respuesta de Axios. A diferencia de Fetch, Axios ya proporciona directamente los datos en response.data, por lo que no es necesario llamar a res.json() en Axios.



function SectionVestidos() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    setLoading(true);

    ListVestidos()
      .then((res) => {
        setItems(res.data);
      })
      .catch((err) => {
        console.error(err);
        alert('Ocurri칩 un error');
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  return <ElementsList items={items} loading={loading} />;
}

export default SectionVestidos;

En este c칩digo corregido, hemos eliminado el segundo .then() donde intentabas llamar a res.json(). En su lugar, simplemente asignamos res.data a setItems(res.data), ya que Axios ya proporciona directamente los datos en response.data.

De esta manera, deber칤as poder manejar correctamente la respuesta de Axios y establecer los datos en el estado items. Adem치s, hemos corregido la funci칩n useState y useEffect import치ndolas directamente desde React.

Recuerda verificar que ListVestidos() de tu archivo Vestidos.js est칠 devolviendo la respuesta de Axios correctamente para que res.data est칠 disponible en el componente SectionVestidos.

//-----------------------------------------------------------------------------------------------------------------------------------------

codigo del fetch en itemlistcontainer

        
//el primero que hice
// ListVestidos()
// .then((res) => {
//      setItems(res.data) //Axios ya proporciona directamente los datos en response.data.
// })
// .catch((err) => {
//     console.error(err)
//     alert('Ocurrio un error')
//     setLoading(false)
// })
// .finally(() => {
//     setLoading(false)
// })
// }, [])



        segundo que funciono con mi api
        function fetchData() {//traigo al API ListVestidos
        //     console.log('Levels', levels)
        //     try{
        //         const res = await ListVestidos(searchLevels(levels))//promesa
        //         setItems(res.data)//resuelvo la promesa
        //     } catch(error) {
        //         console.error(error)
        //         alert('error en base de datos desde sectionVestidos')
        //         setLoading(false)
                
        //     }finally {
        //         setLoading(false)
        //     }
        // } 
        // fetchData()}, [levels])


//----------------------------------------------------------------------------------------------------------------------

este codigo va en itemDetailContainer uso nada mas el params por que me daba error con el location ya que lo vuelve a llamar de nuevo al params

function ListContainerDetail() {
    const [item, setItem] = useState([])
    const [loading, setLoading] = useState(false)

    const {selectedProductId} = useParams()//Hook tengo acceso a selectedproductid
    console.log(selectedProductId)

    // const location = useLocation()//Hook para obtener la ubicacion actual y cualquier estado pasado atraves de la ruta
    // const selectedProductFromLocation  = location.state?.selectedProductId //accedo al estado selectedProductId que paso atraves de la ubicacion

    // const navigate = useNavigate()

    useEffect(() => {
        setLoading(true)

        async function fetchDataD() {
            try{
            if(selectedProductId){
                const res = await getProductsDetail(selectedProductId)
                setItem(res.data)
                console.log(res.data)
            }else{
                // navigate(`/product/${'MLA898739509'}`)//si no me devuelve nada selectedProductFromLocation me devuelva al componente itemListContainer
                console.log('error')
            }
            } catch(error) {
                console.error(error)
                alert('error en base de datos desde itemDetailContainer')
                setLoading(false)
                
            }finally {
                setLoading(false)
            }
        }
    
        fetchDataD()}, [selectedProductId])
        // console.log(item)
    

  return (
    <>
    <ListElementsDetail item={item} loading={loading} selectedProductId={selectedProductId}/>
    {/* quiero entonces leer item cargar un loading y que el selectProductId me mantenga el codigo del producto para poder volver atras sin que me d error de que la base de datos no busque nada */}
    </>
    
  )
}

export default ListContainerDetail


va en el return iba a probar un cambio este funciona asi como esta por lo menos si es true

    <>
        <Box>
        {
        (!item) ?
        
          <Box sx={{display:"flex", justifyContent:"center", alignItems:"center"}}>
          {error && <Button component={Link} to={'/products/all'}>Error: {error.message}</Button>}
          </Box>
          :
          <ListElementsDetail item={item} loading={loading} selectedProductId={selectedProductId}/>
        
        }
    {/* quiero entonces leer item cargar un loading y que el selectProductId me mantenga el codigo del producto para poder volver atras sin que me d error de que la base de datos no busque nada */}
    </Box>
        
    </>

//-----------------------------------------------------------------------------------

personalizacion de botones en navbar
import { styled } from "@mui/material/styles"; //Material Styled Libreria
import { amber, blue, lightBlue } from "@mui/material/colors"; //Material Colors customizables

const CustomButtonsNavBar = styled(Button)(({ theme }) => ({
  //Estilos perzonalizados tipo jsx
  color: theme.palette.getContrastText(lightBlue[50]),
  backgroundColor: blue[200],
  "&:hover": {
    backgroundColor: amber[900],
  },
}));
//------------------------------------------------------------------------------------------------

swal(mensajes de texto)

import Swal from 'sweetalert2'
import withReactContent from 'sweetalert2-react-content'

const MySwal = withReactContent(Swal)

MySwal.fire({
  title: <p>Hello World</p>,
  didOpen: () => {
    // `MySwal` is a subclass of `Swal` with all the same instance & static methods
    MySwal.showLoading()
  },
}).then(() => {
  return MySwal.fire(<p>Shorthand works too</p>)
})
//----------------------------------------------------------------------------------------------------
HandleTrolley del conponente AppContexProvider
 const handlePrToTrolley = (product) => {
      
      // Verificar si ya esta el producto en el carrito
      const productIndex = trolley.findIndex(item => item.id === product.id)

      if(productIndex != -1){
        //El producto ya esta en el carrito, actuliza la cantidad
        const updatedTrolley = [...trolley]
        updatedTrolley[productIndex].quantity 
        += product.quantity
        setTrolley(updatedTrolley)
      } else {
        //El producto no esta en el carrito, agregarlo normalmente
        if(product.quantity <= product.stock){
          setTrolley((prevTrolley) => [...prevTrolley, product])
        } else{
          MySwal.fire({
            title: 'No hay suficiente stock disponible',
            icon: 'error',
            text: 'Lo sentimos, no podemos agregar este producto al carrito debido a la falta de stock.',
          });
          
        }
      }
      
    }

    otra forma

    
    const handlePrToTrolley = (product) => {
      
      // Verificar si ya esta el producto en el carrito
      const productIndex = trolley.findIndex(item => item.id === product.id)

      if(productIndex !== -1){
        //El producto ya esta en el carrito, actuliza la cantidad
        const updatedTrolley = [...trolley]
        updatedTrolley[productIndex].quantity 
        += product.quantity
        setTrolley(updatedTrolley)
      } else {
        //El producto no esta en el carrito, agregarlo si cumple las condiciones de stock
        const existingTrolley = trolley.reduce((total, item) => {
          if(item.id === product.id) {
            return total + item.quantity
          }
          return total
        }, 0)

        const totalQuantity = existingTrolley + product.quantity
      

        if(totalQuantity <= product.stock && totalQuantity <= MAX_STOCK_LIMIT){
        // Restar la cantidad agregada al carrito del stock original
        const updatedStock = product.stock - product.quantity
        product = {...product, stock: updatedStock}
        setTrolley((prevTrolley) => [...prevTrolley, product])
        }else{
          MySwal.fire({
            title: 'No hay suficiente stock disponible',
            icon: 'error',
            text: 'Lo sentimos, no podemos agregar este producto al carrito debido a la falta de stock.',
          });
        }
      }
      
    }

//-------------------------------------------------------------------------------------------------------------------
Componente Moda slide
import * as React from 'react';
import { AppContex } from '../contex-provider';//Contex
//Libreria Material
import { Box, Button, Card, CardContent,CardMedia, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Slide, Typography } from '@mui/material';
//Libreria swal fire
import Swal from 'sweetalert2'
import withReactContent from 'sweetalert2-react-content'
//mi componente
import UserData from '../user-data';


//!Se definen dos componentes Transition y AlertDialogSlide
const Transition = React.forwardRef(function Transition(props, ref) {
  return <Slide direction="top" ref={ref} {...props} />;//se setea una transicion de aparicion del modal.
  
//El componente Transition es una funci칩n que utiliza React.forwardRef para pasar una referencia a otro componente. En este caso, toma dos par치metros: props y ref. Dentro de la funci칩n, retorna un componente <Slide> con la direcci칩n establecida como "up" y la referencia pasada mediante ref. Adem치s, se utiliza el operador spread ({...props}) para pasar todas las dem치s propiedades recibidas a <Slide>. Esto permite que el componente que recibe la referencia tambi칠n tenga acceso a las dem치s propiedades.
});



function ModalSlide({widget}) {//Padre
  //El componente AlertDialogSlide o ModaSlide(nombre que le coloque yo) es un componente funcional que utiliza el hook useState de React para manejar el estado de open, que representa si el di치logo est치 abierto o cerrado. El di치logo se abre cuando se hace clic en el bot칩n "Carrito" y se cierra cuando se hace clic en los botones "Disagree" o "Agree".
  const [open, setOpen] = React.useState(false);
  const {trolley, quantityC, handleEmptyTrolley, notifyToastContainer, notifyToast, createNewDispach, lastDispach} = React.useContext(AppContex)//Contex de carrito

  React.useEffect(() => {
    console.log(quantityC); // Verifica si quantityC se actualiza correctamente
  }, [quantityC]);
  
  const notifyFinish = () => notifyToast('游눧 Compra Terminada Correctamente')//notificaciones

  const MySwal = withReactContent(Swal)//instancia sweetalert
    const handleClickSwal = () => {//evento sweetalert 
      console.log(quantityC)
      
      if(quantityC >= 1) {
        setOpen(false)//cierro el modal
      MySwal.fire({//abro sweetalert
        title: 'Venta Registada',
        html: `Muchas gracias por preferirnos, su factura a abonar es de ${calcwithIva()} Pesos.<br>Le estaremos enviando la factura a su correo electronico con la cantidad de # ${calcTotalPerItemsCart()} productos.`,
        icon: 'success',
        confirmButtonText: 'OK',
        timer:3500,
      })
      
      handleEmptyTrolley()//Vaciar el carrito desde el boton terminar compra
      }else {
        setOpen(false)//cierro el modal
      MySwal.fire({//abro sweetalert
          title: 'Error',
          title: "Debe anadir un producto al carrito",
          icon: 'warning',
          showConfirmButton: false,
          timer:2000,
        })
        }
    };

  const calcTotalPerItemsCart = () => {//Calcular la cantidad de items que lleva entre productos (no tiene nada que ver con calculo de precios)
    let totalQuantity = 0

    for(const item of trolley){ totalQuantity += item.quantity } return totalQuantity }

  const calcTotalQuantityPerPrice = (item) => {//Calcular la cantidad que lleva con el precio y la unidad
    return item.pricePerUnit * item.quantity
  }
  
  const calcTotalGlobalPay = () => {//Calcular el total de todo el carrito sin iva
    let totalGlobal = 0

    for (const item of trolley) { totalGlobal += calcTotalQuantityPerPrice(item) } return totalGlobal.toFixed(2)
  }

  const calcwithIva = () => {//Calcular el total de todo el carrito con iva
    let totalWithIva = 0
    for (const item of trolley) { totalWithIva += calcTotalQuantityPerPrice(item) * 1.21 } return totalWithIva.toFixed(2)
  } 

  const handleClickOpen = () => {//abrir y cerrar el modal
    setOpen(true);
  };

  const handleClose = () => {//abrir y cerrar el modal + setear a vacio el array cuando se cierre
    setOpen(false);
    notifyFinish()
  };

 

  return (
    <div>
      {/*Cuando se hace clic en el bot칩n "Carrito", se invoca la funci칩n handleClickOpen, lo que establece el estado open en true y muestra el di치logo. */}
      <Button variant="text" onClick={handleClickOpen}>
       {widget}
      </Button>
      {/* El di치logo est치 representado por el componente Dialog de React. Se le pasa la prop open para indicar si el di치logo debe estar visible o no. La prop TransitionComponent se establece en el componente Transition que mencion칠 anteriormente para proporcionar la transici칩n animada. */}
      <Dialog
        open={open}
        TransitionComponent={Transition}
        keepMounted
        onClose={handleClose}
        aria-describedby="alert-dialog-slide-description"
        
      >
        
        {/* formato UI del card en el modal */}
        <DialogTitle fontFamily={"fantasy"} >{"Tus Productos"}</DialogTitle>
        <DialogContent >
          <DialogContentText  id="alert-dialog-slide-description">
            {
              trolley.map((item) => (
              <Card key={item.id} sx={{display:"flex", justifyContent:"space-between", alignItems:"strech",  marginBottom: '.3rem', boxShadow: '2px 2px 4px rgba(0, 0, 0, 0.2)' }} >
                  <CardMedia
                  component="img"
                  sx={{ width: 100, objectFit:"cover" }}
                  image={item.imagen}
                  alt={item.producto}
                  />
                <CardContent sx={{display:"flex", flexDirection:"column" ,alignItems:"self-start"}}>
                  <Typography sx={{width:'200px', textAlign:'left', lineHeight:1, marginBottom:"5px"}} flexWrap="nowrap" variant="h6" component="p">
                    {item.producto}
                  </Typography>
                  <Typography variant="body2" component='p' color="textSecondary">
                    Valor Unid: {item.pricePerUnit}
                  </Typography>
                  <Typography variant="body2" component="p">
                    Vas a llevar: {item.quantity}
                  </Typography>
                  <Typography variant="body2" component="p">
                    Total: {calcTotalQuantityPerPrice(item)}
                  </Typography>
                 
                </CardContent>
              
              </Card>
             ))}
          </DialogContentText>
        </DialogContent>

        <Box display={'flex'} flexDirection={'column'} justifyContent={"space-around"} flexWrap={'wrap'} margin={"0 1rem"}>
            <Box display={'flex'} flexDirection={'row'} justifyContent={"center"} gap={"1rem"} textTransform={"capitalize"}>

            <Typography fontFamily={"fantasy"} variant="body2" component="p">
                Items en Carrito: {quantityC} 
            </Typography>
            <Typography fontFamily={"fantasy"} variant="body2" component="p">
                Cantidad Total Items: {calcTotalPerItemsCart()} 
            </Typography>
            </Box>
            
            <Box display={"flex"} justifyContent={"center"}>
              <Typography variant="h6" component="p">
                Total Pago S/Iva: {calcTotalGlobalPay()} Pesos
            </Typography>
            </Box>
            <Box display={"flex"} justifyContent={"center"}>
              <Typography variant="body1" component="p">
                C/Iva: {calcwithIva()} Pesos
            </Typography>
            </Box>
        </Box>
      
        <DialogActions>
          <Button onClick={handleEmptyTrolley}>Vaciar</Button>{notifyToastContainer()}
          <Button onClick={handleEmptyTrolley}>Eliminar</Button>
          <Button onClick={handleClickSwal}>Terminar Compra</Button>
        </DialogActions>
        <Box>
        <UserData trolley={trolley} createNewDispach={createNewDispach} lastDispach={lastDispach}/>
      </Box>
      </Dialog>
   
    </div>
  );
}

export default ModalSlide

//La propiedad variant en Typography se utiliza para especificar el estilo o variante de tipograf칤a que deseas utilizar. Puedes elegir entre diferentes valores predefinidos, como "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "caption" y "button". Cada valor tiene un estilo y tama침o de fuente asociado. Por ejemplo, variant="h6" aplicar치 un estilo de encabezado de nivel 6 a ese componente Typography.

//La propiedad component en Typography se utiliza para especificar el elemento HTML que se renderizar치 para ese componente Typography. Puedes elegir entre diferentes valores, como "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "caption", "button", "p", "span", etc. Por ejemplo, component="h2" indica que el componente Typography se renderizar치 como un elemento de encabezado de nivel 2 (<h2>).

//* El componente <Dialog> se utiliza para representar el di치logo emergente. Tiene varias propiedades, incluyendo open que recibe el estado open, TransitionComponent que recibe el componente Transition definido anteriormente, onClose que recibe la funci칩n handleClose para manejar el cierre del di치logo, y aria-describedby para proporcionar una descripci칩n accesible del di치logo. //Dentro de <Dialog>, se encuentran otros componentes como <DialogTitle>, <DialogContent>, <DialogContentText> y <DialogActions>, que se utilizan para estructurar y mostrar el contenido del di치logo. En este caso, muestra un t칤tulo, un texto de contenido y dos botones de acciones ("Disagree" y "Agree") que llaman a la funci칩n handleClose cuando se hace clic en ellos.*/

//* La propiedad aria-describedby es una convenci칩n de accesibilidad que se utiliza para asociar un elemento en la p치gina con una descripci칩n que brinda m치s informaci칩n sobre ese elemento. En este caso, el di치logo emergente tiene un elemento con id="alert-dialog-slide-description", y la propiedad aria-describedby se establece en ese ID para vincular la descripci칩n al di치logo. */
/------------------------------------------------------------------------------------------------------------------------------------------------
//Codigo pra handletrolly el manejador del carrito cuando agrego productos precisamente al carrito
 
 const handlePrToTrolley = (product) => {
      // Verificar si ya esta el producto en el carrito
      const productIndex = trolley.findIndex(item => item.id === product.id)

      if(productIndex !== -1){
        //El producto ya esta en el carrito, actuliza la cantidad
      
        const updatedTrolley =[...trolley]
        const newQuantity = updatedTrolley[productIndex].quantity + product.quantity
        
        // updatedTrolley[productIndex].quantity += product.quantity //En esta versi칩n, en lugar de usar un objeto separado para actualizar la cantidad del producto, estamos actualizando directamente la propiedad quantity del objeto existente en el carrito utilizando el 칤ndice productIndex y sumando la cantidad del nuevo producto (product.quantity). Esto tiene el mismo efecto que el c칩digo original pero de forma m치s concisa.

        if(newQuantity <= parseInt(product.stock)) {
          updatedTrolley[productIndex].quantity = newQuantity

          setTrolley(updatedTrolley)
        }else {
          MySwal.fire({
            title: 'No hay suficiente stock disponible',
            icon: 'error',
            text: 'Lo sentimos, no podemos agregar este producto al carrito debido a la falta de stock.',
          });
        }
        // setTrolley(updatedTrolley)//Se actualiza el estado del carrito utilizando setTrolley con la copia actualizada del carrito.
      } else {
        //El producto no esta en el carrito, agregarlo si cumple las condiciones de stock
        const existingTrolley = trolley.reduce((total, item) => {//Se utiliza la funci칩n reduce para calcular la cantidad total de productos con el mismo id en el carrito actual. Comienza con un valor inicial de 0 y, para cada elemento del carrito, se verifica si el id coincide con el del producto que se desea agregar. Si es as칤, se suma la cantidad del producto actual al total acumulado.
          if(item.id === product.id) {
            return total + item.quantity
          }
          return total
        }, 0)

        const totalQuantity = existingTrolley + product.quantity //Luego de calcular la cantidad total de productos con el mismo id en el carrito
        // se verifica que no exceda el stock disponible y el l칤mite m치ximo

        console.log('totalQuantity:', totalQuantity);
        console.log('product.stock:', product.stock);

        if(totalQuantity <= parseInt(product.stock)){// se verifica si la cantidad total de un producto en el carrito, incluida la cantidad que se desea agregar, es menor o igual al stock disponible para ese producto (product.stock).
        // Restar la cantidad agregada al carrito del stock original
        setTrolley((prevTrolley) => [...prevTrolley, product])
        
        }else{
          MySwal.fire({
            title: 'No hay suficiente stock disponible',
            icon: 'error',
            text: 'Lo sentimos, no podemos agregar este producto al carrito debido a la falta de stock.',
          });
        }
      }
    }
//---------------------------------------------------------------------------------------------------------------------------------------------

